# Permutations (20 分)

## 题目
对于一个由 `n` 个互不相同的整数构成的排列,
请按照**注解**中给出的方法 (也可以使用其它方法), 求出该排列的**下一个排列**。

### 排列
本题所说的排列就是大家在高中阶段学习的排列的概念。

例如,
- `1 2 3` 与 `3 1 2` 都是长度为 `3` 的排列
- `2 2 1` 不是排列
- 长度为 `n` 的排列共有 `n!` 个

### 下一个排列
**下一个**是字典序意义上的下一个。

例如, 长度为 `3` (假设由 `1 2 3` 构成) 的排列按照字典序升序排序如下:
- `1 2 3`
- `1 3 2`
- `2 1 3`
- `2 3 1`
- `3 1 2`
- `3 2 1`

`2 3 1` 的下一个排列就是 `3 1 2`。

## 你的任务
请在 `Perm.java` 中实现方法 `public void nextPermutation(List<Integer> perm)`:
- 参数 `perm` 表示输入的排列, 用 `List` 存储
- 无返回值。也就是说, 你需要直接修改 `perm`。

## 注解
### 求下一个排列的方法（请结合下面的例子一起理解）
- 找出输入排列的最长连续递降后缀，其长度记为 `m` (`m < n`)
- 找到最长连续递降后缀之前的那个数，记为 `pi`
- 在最长连续递降后缀中找到比 `pi` 大的数中最小的那个数, 记为 `pj`
- 交换 `pi` 与 `pj`
- 将交换后的序列中的最后 `m` 个数逆转

### 例子
假设输入排列为 `1 3 5 4 2`:
- 最长连续递降后缀为 `5 4 2`  (长度 `m = 3`)
  - 不为 `3 5 4 2`, 因为 `3 5` 不递降
  - 不为 `4 2`, 因为不是"最长"的
  - 不为 `5 2`，因为不是"最长"的, 也不是连续的
- 最长连续递降后缀之前的那个数为 `3` (即 `pi = 3`)
- 最长连续递降后缀中比 `3` 大的数中最小的是 `4` (即 `pj = 4`)
- 交换 `pi` 与 `pj` 后为 `1 4 5 3 2`
- 将上面序列中最后 `m = 3` 个数逆转, 得到 `1 4 2 3 5`, 即为所求的下一个排列

## 公开测试用例 (公开测试用例也是计分的! 另外有 15 个非公开测试用例)
### test 1
- 输入排列: `1 2 3 4 5`
- 下一个排列: `1 2 3 5 4`
 
### test 2
- 输入排列: `3 1 2 5 4`
- 下一个排列: `3 1 4 2 5`

### test 3
- 输入排列: `3 1 2`
- 下一个排列: `3 2 1`

### test 4
- 输入排列: `4 5 3 2 1 6`
- 下一个排列: `4 5 3 2 6 1`

### test 5
- 输入排列: `8 7 6 5 4 3 1 2`
- 下一个排列: `8 7 6 5 4 3 2 1`